# CodeMedic Plugin Architecture

## Overview

CodeMedic supports an extensible plugin system that allows developers to:
- Create custom analysis engines that integrate with the repository health dashboard
- Develop specialized reporters for custom output formats
- Add new CLI commands without modifying core application code
- Build custom data processors for specialized transformations

This document provides comprehensive guidance on developing, packaging, and integrating plugins with CodeMedic.

**Current Status**: The plugin infrastructure is fully implemented with two internal plugins:
- **HealthAnalysisPlugin** - Repository health and code quality analysis
- **BomAnalysisPlugin** - Bill of Materials generation

Both plugins demonstrate the plugin architecture and serve as reference implementations.

---

## Core Concepts

### Plugin Types

CodeMedic supports four types of plugins:

#### 1. Analysis Engine Plugins (`IAnalysisEnginePlugin`)
Contribute custom scanning and analysis capabilities to CodeMedic.

**Responsibilities:**
- Scan repositories for specific health indicators
- Return structured analysis results
- Provide meaningful descriptions of findings

**Example Use Cases:**
- Custom security vulnerability scanner
- Architecture compliance checker
- Performance profiler
- Code duplication detector

#### 2. Reporter Plugins (`IReporterPlugin`)
Add custom output formatters and report generators.

**Responsibilities:**
- Accept analysis results in standard formats
- Transform and format data for specific output targets
- Support both human-readable and machine-readable formats

**Example Use Cases:**
- SARIF format reporter for security findings
- HTML report generator
- Markdown report formatter
- Integration with external reporting systems

#### 3. Command Plugins (`ICommandPlugin`)
Extend the CLI with custom commands.

**Responsibilities:**
- Define CLI command structure and options
- Execute command logic
- Return exit codes and output

**Example Use Cases:**
- `codemedic scan-vulnerabilities` - dedicated vulnerability scanner command
- `codemedic audit-licenses` - license compliance auditor
- `codemedic export-compliance` - compliance report exporter

#### 4. Processor Plugins (`IProcessorPlugin`)
Transform and enrich scan data before reporting.

**Responsibilities:**
- Accept raw analysis data
- Apply transformations, enrichment, or filtering
- Output processed data

**Example Use Cases:**
- Data aggregator combining results from multiple engines
- Risk scorer for dependencies
- Compliance rule evaluator
- Metric calculator

---

## Plugin Interface Definitions

### IAnalysisEnginePlugin

```csharp
namespace CodeMedic.Abstractions.Plugins;

public interface IAnalysisEnginePlugin : IPlugin
{
    /// <summary>
    /// Gets a short description of what this engine analyzes.
    /// </summary>
    string AnalysisDescription { get; }

    /// <summary>
    /// Scans the repository and returns analysis results as a structured object.
    /// </summary>
    /// <param name="repositoryPath">Path to the root of the repository to analyze.</param>
    /// <param name="cancellationToken">Cancellation token for long-running operations.</param>
    /// <returns>Analysis result data as an object that can be rendered (typically a ReportDocument).</returns>
    Task<object> AnalyzeAsync(string repositoryPath, CancellationToken cancellationToken = default);
}
```

### IReporterPlugin

```csharp
namespace CodeMedic.Abstractions.Plugins;

public interface IReporterPlugin : IPlugin
{
    /// <summary>
    /// Gets the output format this reporter produces (e.g., "json", "markdown", "html").
    /// </summary>
    string OutputFormat { get; }

    /// <summary>
    /// Gets the file extension for reports generated by this reporter (e.g., ".json", ".md").
    /// </summary>
    string FileExtension { get; }

    /// <summary>
    /// Formats the analysis result and returns it as a string.
    /// </summary>
    /// <param name="analysisResult">The analysis result to format.</param>
    /// <param name="cancellationToken">Cancellation token.</param>
    /// <returns>Formatted output as a string.</returns>
    Task<string> FormatAsync(object analysisResult, CancellationToken cancellationToken = default);

    /// <summary>
    /// Writes the formatted report to the specified output path.
    /// </summary>
    /// <param name="analysisResult">The analysis result to format and write.</param>
    /// <param name="outputPath">The file path to write the report to.</param>
    /// <param name="cancellationToken">Cancellation token.</param>
    Task WriteReportAsync(object analysisResult, string outputPath, CancellationToken cancellationToken = default);
}
```

### ICommandPlugin (Future)

*Not yet implemented. Planned for future release.*

```csharp
namespace CodeMedic.Abstractions.Plugins;

public interface ICommandPlugin : IPlugin
{
    string CommandName { get; }
    string CommandDescription { get; }
    Task<int> ExecuteAsync(string[] args, CancellationToken cancellationToken);
}
```

### IProcessorPlugin (Future)

*Not yet implemented. Planned for future release.*

```csharp
namespace CodeMedic.Abstractions.Plugins;

public interface IProcessorPlugin : IPlugin
{
    string ProcessorDescription { get; }
    Task<string> ProcessAsync(string inputData, CancellationToken cancellationToken);
}
```

### IPlugin (Base Interface)

```csharp
namespace CodeMedic.Abstractions.Plugins;

public interface IPlugin
{
    /// <summary>
    /// Gets the plugin metadata describing its identity and capabilities.
    /// </summary>
    PluginMetadata Metadata { get; }

    /// <summary>
    /// Initializes the plugin with any necessary configuration.
    /// </summary>
    /// <param name="cancellationToken">Cancellation token for async initialization.</param>
    /// <returns>A task that completes when initialization is done.</returns>
    Task InitializeAsync(CancellationToken cancellationToken = default);
}
```

### PluginMetadata

```csharp
namespace CodeMedic.Abstractions.Plugins;

public class PluginMetadata
{
    /// <summary>
    /// Gets or sets the unique identifier for the plugin.
    /// </summary>
    public required string Id { get; init; }

    /// <summary>
    /// Gets or sets the display name of the plugin.
    /// </summary>
    public required string Name { get; init; }

    /// <summary>
    /// Gets or sets the plugin version.
    /// </summary>
    public required string Version { get; init; }

    /// <summary>
    /// Gets or sets a brief description of what the plugin does.
    /// </summary>
    public required string Description { get; init; }

    /// <summary>
    /// Gets or sets the plugin author or maintainer.
    /// </summary>
    public string? Author { get; init; }

    /// <summary>
    /// Gets or sets any additional tags or categories for the plugin.
    /// </summary>
    public string[]? Tags { get; init; }
}
```

---

## Plugin Development Workflow

### Step 1: Create the Plugin Project

Create a new .NET 10 class library project:

```bash
dotnet new classlib -n CodeMedic.Plugin.MyAnalyzer -f net10.0
cd CodeMedic.Plugin.MyAnalyzer
```

### Step 2: Reference CodeMedic.Abstractions

Add a reference to the abstractions package in your `.csproj`:

```xml
<ItemGroup>
    <PackageReference Include="CodeMedic.Abstractions" Version="1.0.0" />
</ItemGroup>
```

### Step 3: Implement a Plugin Interface

#### Example: Analysis Engine Plugin

```csharp
using CodeMedic.Abstractions.Plugins;
using CodeMedic.Models.Report;

namespace CodeMedic.Plugin.MyAnalyzer;

public class MyAnalyzerPlugin : IAnalysisEnginePlugin
{
    public PluginMetadata Metadata => new()
    {
        Id = "mycompany.myanalyzer",
        Name = "My Custom Analyzer",
        Version = "1.0.0",
        Author = "Your Name",
        Description = "Analyzes code for custom metrics",
        Tags = new[] { "custom-analysis", "metrics" }
    };

    public string AnalysisDescription => "Performs custom code analysis";

    public Task InitializeAsync(CancellationToken cancellationToken = default)
    {
        // Initialize plugin resources (e.g., load configuration, validate environment)
        return Task.CompletedTask;
    }

    public async Task<object> AnalyzeAsync(string repositoryPath, CancellationToken cancellationToken = default)
    {
        // Perform analysis and return a ReportDocument
        var report = new ReportDocument
        {
            Title = "Custom Analysis Report"
        };

        var section = new ReportSection
        {
            Title = "Analysis Results",
            Level = 1
        };

        section.AddElement(new ReportParagraph(
            "Custom analysis completed successfully.",
            TextStyle.Success
        ));

        report.AddSection(section);
        return report;
    }
}
```

### Step 4: Build and Test

Build your plugin:

```bash
dotnet build
```

For internal plugins (within the CodeMedic solution), the plugin will be automatically discovered by the `PluginLoader` when it scans the executing assembly.

For external plugins (future capability), you'll package the plugin DLL for distribution.
### Step 4: Build and Test

Build your plugin:

```bash
dotnet build
```

For internal plugins (within the CodeMedic solution), the plugin will be automatically discovered by the `PluginLoader` when it scans the executing assembly.

For external plugins (future capability), you'll package the plugin DLL for distribution.

---

## Internal Plugins

### Current Implementation

CodeMedic currently includes two internal plugins as reference implementations:

#### 1. HealthAnalysisPlugin

Location: `src/CodeMedic/Plugins/HealthAnalysisPlugin.cs`

**Purpose**: Provides repository health analysis including projects, dependencies, and code quality indicators.

**Key Features**:
- Scans .NET projects in repository
- Analyzes NuGet dependencies (direct and transitive)
- Evaluates code quality settings (Nullable, ImplicitUsings, Documentation)
- Identifies package version mismatches
- Generates comprehensive health report

**Plugin ID**: `codemedic.health`

**Usage**:
```bash
codemedic health
codemedic health --format markdown
```

#### 2. BomAnalysisPlugin

Location: `src/CodeMedic/Plugins/BomAnalysisPlugin.cs`

**Purpose**: Generates Bill of Materials (BOM) with comprehensive dependency inventory.

**Key Features**:
- Enumerates all NuGet packages across projects
- Tracks direct dependencies
- Shows which projects use each package
- Placeholder sections for framework features and external services (future enhancement)

**Plugin ID**: `codemedic.bom`

**Usage**:
```bash
codemedic bom
codemedic bom --format markdown
```

### Creating Internal Plugins

To add a new internal plugin:

1. Create a new class in `src/CodeMedic/Plugins/`
2. Implement `IAnalysisEnginePlugin` or `IReporterPlugin`
3. Provide unique plugin ID in metadata
4. Build the project - plugin is automatically discovered
5. Optionally add a new command in `RootCommandHandler.cs`

---

## Plugin Discovery & Loading

### Current Implementation

The `PluginLoader` utility (located at `src/CodeMedic/Utilities/PluginLoader.cs`) manages plugin discovery and lifecycle.

**Discovery Process**:

1. **Load Internal Plugins**: Scans the executing assembly for plugin implementations
2. **Reflect on Types**: Uses reflection to find types implementing `IPlugin` interface
3. **Instantiate Plugins**: Creates instances of discovered plugins
4. **Initialize Plugins**: Calls `InitializeAsync()` on each plugin
5. **Register by Type**: Organizes plugins by type (Analysis Engine, Reporter, etc.)

**Current Scope**: Only internal plugins are supported. External plugin loading from directories is planned for a future release.

### PluginLoader API

```csharp
public class PluginLoader
{
    /// <summary>
    /// Gets all loaded analysis engine plugins.
    /// </summary>
    public IReadOnlyList<IAnalysisEnginePlugin> AnalysisEngines { get; }

    /// <summary>
    /// Gets all loaded reporter plugins.
    /// </summary>
    public IReadOnlyList<IReporterPlugin> Reporters { get; }

    /// <summary>
    /// Discovers and loads internal plugins from the current assembly.
    /// </summary>
    public async Task LoadInternalPluginsAsync(CancellationToken cancellationToken = default);

    /// <summary>
    /// Gets an analysis engine plugin by its ID.
    /// </summary>
    public IAnalysisEnginePlugin? GetAnalysisEngine(string pluginId);

    /// <summary>
    /// Gets a reporter plugin by its output format.
    /// </summary>
    public IReporterPlugin? GetReporter(string format);
}
```

### Usage Example

```csharp
// In a command handler
var pluginLoader = new PluginLoader();
await pluginLoader.LoadInternalPluginsAsync();

// Get specific plugin
var healthPlugin = pluginLoader.GetAnalysisEngine("codemedic.health");
if (healthPlugin != null)
{
    var result = await healthPlugin.AnalyzeAsync(repositoryPath);
    renderer.RenderReport(result);
}
```
### Future: External Plugin Loading

*Planned for future release*

External plugin loading will support:
- Loading plugins from `~/.codemedic/plugins/` directory
- Loading plugins from `./plugins/` relative to current directory
- Plugin dependency resolution
- Version compatibility checking
- Security validation

---

## Integration Points

### Command Integration

Plugins integrate with commands through the `PluginLoader`:

```csharp
// Load plugins
var pluginLoader = new PluginLoader();
await pluginLoader.LoadInternalPluginsAsync();

// Get and execute analysis plugin
var plugin = pluginLoader.GetAnalysisEngine("codemedic.health");
if (plugin != null)
{
    var reportDocument = await plugin.AnalyzeAsync(repositoryPath);
    renderer.RenderReport(reportDocument);
}
```

### Current Commands Using Plugins

**HealthCommand** (`src/CodeMedic/Commands/HealthCommand.cs`)
- Uses `codemedic.health` plugin
- Supports `--format` option for output

**BomCommand** (`src/CodeMedic/Commands/BomCommand.cs`)
- Uses `codemedic.bom` plugin
- Supports `--format` option for output

### Data Flow

```
Repository â†’ PluginLoader â†’ Analysis Plugin â†’ ReportDocument â†’ Renderer â†’ Output
                              (HealthAnalysisPlugin)
                              (BomAnalysisPlugin)
```

---

## Best Practices

### 1. Error Handling
- Handle and report errors gracefully
- Provide meaningful error messages to users
- Use try-catch blocks to prevent crashes
- Log errors at appropriate levels

### 2. Performance
- Implement cancellation token support
- Show progress for long-running operations
- Optimize for large repositories
- Cache results when appropriate

### 3. Cross-Platform Compatibility
- Test on Windows, macOS, and Linux
- Use cross-platform APIs
- Handle path differences appropriately
- Ensure console output works everywhere

### 4. Code Quality
- Follow C# naming conventions
- Enable nullable reference types
- Use implicit usings
- Write unit tests
- Document public APIs

### 5. Security
- Validate all inputs
- Don't execute untrusted code
- Sanitize output before displaying
- Handle sensitive data carefully

### 6. Documentation
- Include README in plugin package
- Document all public methods
- Provide usage examples
- Include troubleshooting guide

---

## Testing Plugins

### Unit Testing

Create unit tests within your plugin project or in the test suite:

```csharp
using Xunit;
using CodeMedic.Utilities;

namespace Test.CodeMedic.Utilities;

public class PluginLoaderTests
{
    [Fact]
    public async Task LoadInternalPlugins_LoadsHealthPlugin()
    {
        // Arrange
        var loader = new PluginLoader();

        // Act
        await loader.LoadInternalPluginsAsync();

        // Assert
        Assert.NotEmpty(loader.AnalysisEngines);
        
        var healthPlugin = loader.GetAnalysisEngine("codemedic.health");
        Assert.NotNull(healthPlugin);
        Assert.Equal("codemedic.health", healthPlugin.Metadata.Id);
    }

    [Fact]
    public async Task AnalyzeAsync_WithValidRepository_ReturnsResults()
    {
        // Arrange
        var loader = new PluginLoader();
        await loader.LoadInternalPluginsAsync();
        var plugin = loader.GetAnalysisEngine("codemedic.health");
        var repoPath = Directory.GetCurrentDirectory();

        // Act
        var result = await plugin!.AnalyzeAsync(repoPath);

        // Assert
        Assert.NotNull(result);
    }
}
```

### Integration Testing

Test plugins by running CodeMedic commands:

```bash
# Test health plugin
dotnet run -- health

# Test BOM plugin
dotnet run -- bom

# Test with markdown output
dotnet run -- health --format markdown > output.md
```

---

## Distribution

### Internal Plugins

Internal plugins are distributed as part of the CodeMedic application. They are built into the main assembly and automatically discovered at runtime.

### External Plugins (Future)

*Planned for future release*

External plugins will support multiple distribution methods:

#### NuGet Package
```bash
dotnet pack -c Release
dotnet nuget push bin/Release/CodeMedic.Plugin.MyAnalyzer.1.0.0.nupkg --api-key YOUR_API_KEY
```

#### Standalone Distribution
1. Build the plugin assembly
2. Create a zip file with plugin DLL and dependencies
3. Distribute via GitHub Releases or plugin registry

#### Plugin Registry
CodeMedic will support a central plugin registry:
```bash
codemedic plugin install my-analyzer
codemedic plugin list
codemedic plugin update
codemedic plugin remove my-analyzer
```

---

## Versioning & Compatibility

### Semantic Versioning

Plugins use semantic versioning (MAJOR.MINOR.PATCH):

- **MAJOR**: Breaking changes to plugin interface or capabilities
- **MINOR**: New features added in backward-compatible manner
- **PATCH**: Bug fixes and improvements

### Plugin Versioning

Internal plugins use the application version from Nerd Bank Git Versioning:

```csharp
public PluginMetadata Metadata => new()
{
    Id = "codemedic.health",
    Name = "Repository Health Analyzer",
    Version = VersionUtility.GetVersion(),  // Uses NBGv2
    // ...
};
```

### Future: Compatibility Checking

*Planned for future release*

External plugin support will include:
- Minimum CodeMedic version requirements
- Compatibility validation before loading
- Warning for incompatible plugins

---

## Examples

### Example 1: HealthAnalysisPlugin (Actual Implementation)

Location: `src/CodeMedic/Plugins/HealthAnalysisPlugin.cs`

```csharp
using CodeMedic.Abstractions.Plugins;
using CodeMedic.Engines;
using CodeMedic.Models.Report;
using CodeMedic.Utilities;

namespace CodeMedic.Plugins;

public class HealthAnalysisPlugin : IAnalysisEnginePlugin
{
    private RepositoryScanner? _scanner;

    public PluginMetadata Metadata => new()
    {
        Id = "codemedic.health",
        Name = "Repository Health Analyzer",
        Version = VersionUtility.GetVersion(),
        Description = "Analyzes .NET repository health, including projects, dependencies, and code quality indicators",
        Author = "CodeMedic Team",
        Tags = ["health", "analysis", "repository", "dotnet"]
    };

    public string AnalysisDescription => "Repository health and code quality analysis";

    public Task InitializeAsync(CancellationToken cancellationToken = default)
    {
        return Task.CompletedTask;
    }

    public async Task<object> AnalyzeAsync(string repositoryPath, CancellationToken cancellationToken = default)
    {
        _scanner = new RepositoryScanner(repositoryPath);
        await _scanner.ScanAsync();
        
        var reportDocument = _scanner.GenerateReport();
        return reportDocument;
    }
}
```

### Example 2: BomAnalysisPlugin (Actual Implementation)

Location: `src/CodeMedic/Plugins/BomAnalysisPlugin.cs`

```csharp
using CodeMedic.Abstractions.Plugins;
using CodeMedic.Engines;
using CodeMedic.Models.Report;
using CodeMedic.Utilities;

namespace CodeMedic.Plugins;

public class BomAnalysisPlugin : IAnalysisEnginePlugin
{
    private NuGetInspector? _inspector;

    public PluginMetadata Metadata => new()
    {
        Id = "codemedic.bom",
        Name = "Bill of Materials Analyzer",
        Version = VersionUtility.GetVersion(),
        Description = "Generates comprehensive Bill of Materials including NuGet packages, frameworks, services, and vendors",
        Author = "CodeMedic Team",
        Tags = ["bom", "dependencies", "inventory", "packages"]
    };

    public string AnalysisDescription => "Comprehensive dependency and service inventory (BOM)";

    public Task InitializeAsync(CancellationToken cancellationToken = default)
    {
        return Task.CompletedTask;
    }

    public async Task<object> AnalyzeAsync(string repositoryPath, CancellationToken cancellationToken = default)
    {
        _inspector = new NuGetInspector(repositoryPath);
        await _inspector.RestorePackagesAsync();
        _inspector.RefreshCentralPackageVersionFiles();

        var bomReport = GenerateBomReport(repositoryPath);
        return bomReport;
    }

    private ReportDocument GenerateBomReport(string repositoryPath)
    {
        // ... implementation details ...
    }
}
```

### Example 3: Custom Security Scanner (Conceptual)

```csharp
public class SecurityScannerPlugin : IAnalysisEnginePlugin
{
    public PluginMetadata Metadata => new()
    {
        Id = "mycompany.security",
        Name = "Security Scanner",
        Version = "1.0.0",
        Author = "Security Team",
        Description = "Scans dependencies for known vulnerabilities",
        Tags = ["security", "vulnerability-scanning"]
    };

    public string AnalysisDescription => "Vulnerability analysis";

    public Task InitializeAsync(CancellationToken cancellationToken = default)
    {
        // Initialize vulnerability database
        return Task.CompletedTask;
    }

    public async Task<object> AnalyzeAsync(string repositoryPath, CancellationToken cancellationToken = default)
    {
        var report = new ReportDocument { Title = "Security Analysis" };
        
        // Scan for vulnerabilities
        var vulnerabilities = await ScanForVulnerabilitiesAsync(repositoryPath, cancellationToken);
        
        var section = new ReportSection
        {
            Title = "Vulnerabilities Found",
            Level = 1
        };
        
        // Add findings to report
        // ...
        
        report.AddSection(section);
        return report;
    }

    private Task<List<object>> ScanForVulnerabilitiesAsync(string repositoryPath, CancellationToken cancellationToken)
    {
        // Implementation
        throw new NotImplementedException();
    }
}
```

---

## Troubleshooting

### Internal Plugin Issues

**Plugin Not Being Discovered**:
1. Ensure plugin class implements `IPlugin` interface (and specific plugin type interface)
2. Ensure plugin class is not abstract and has a parameterless constructor
3. Verify plugin is in the same assembly as the application
4. Check for compilation errors

**Plugin Initialization Fails**:
1. Check `InitializeAsync()` method for exceptions
2. Review error messages in console output
3. Verify all dependencies are available
4. Test plugin in isolation with unit tests

**Analysis Fails**:
1. Validate repository path is correct
2. Check for file system permissions
3. Ensure all required NuGet packages are restored
4. Review error output for specific failure details

### Future: External Plugin Troubleshooting

*Will be documented when external plugin support is implemented*

- Plugin loading from directories
- Dependency resolution issues
- Version compatibility problems
- Security validation failures
## Contributing Plugins

### Internal Plugins

To contribute an internal plugin to CodeMedic:

1. Fork the CodeMedic repository
2. Create a new plugin class in `src/CodeMedic/Plugins/`
3. Implement `IAnalysisEnginePlugin` or `IReporterPlugin`
4. Add comprehensive unit tests in `test/Test.CodeMedic/`
5. Update documentation
6. Submit a pull request

### External Plugins (Future)

When external plugin support is available:

1. Create plugin following this guide
2. Package as NuGet or standalone DLL
3. Test thoroughly on all platforms
4. Document usage and configuration
5. Submit to plugin registry
6. Maintain compatibility with newer CodeMedic versions

---

## Support & Resources

- **Documentation**: https://github.com/csharpfritz/codemedic
- **Issue Tracker**: https://github.com/csharpfritz/codemedic/issues
- **Discussions**: https://github.com/csharpfritz/codemedic/discussions

## Summary

The CodeMedic plugin architecture provides:

âœ… **Implemented**:
- Core plugin interfaces (`IPlugin`, `IAnalysisEnginePlugin`, `IReporterPlugin`)
- Plugin metadata system
- Internal plugin discovery and loading
- Two reference implementations (Health and BOM plugins)
- Full integration with command system
- Comprehensive testing support

ðŸ”œ **Planned**:
- External plugin loading from directories
- Plugin dependency resolution
- Version compatibility checking
- Command and Processor plugin types
- Plugin registry and marketplace
- Plugin management CLI commands

The current implementation demonstrates a solid foundation for extensibility while keeping plugins internal to maintain simplicity and security. Future enhancements will enable community plugin development and distribution.
