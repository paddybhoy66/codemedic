using CodeMedic.Abstractions;
using CodeMedic.Abstractions.Plugins;
using CodeMedic.Models;
using CodeMedic.Models.Report;
using CodeMedic.Output;
using CodeMedic.Plugins.VulnerabilityAnalysis;
using Moq;

namespace Test.CodeMedic.Plugins.VulnerabilityAnalysis;

/// <summary>
/// Unit tests for VulnerabilityAnalysisPlugin using Given-When-Then syntax.
/// </summary>
public class VulnerabilityAnalysisPluginTests
{
    /// <summary>
    /// Gets a cross-platform root path for testing.
    /// </summary>
    private static string TestRootPath => OperatingSystem.IsWindows()
        ? @"C:\TestRepo"
        : "/tmp/TestRepo";

    #region Metadata Tests

    [Fact]
    public void Metadata_GivenPluginInstance_WhenAccessingMetadata_ThenReturnsValidMetadata()
    {
        // Given
        var plugin = new VulnerabilityAnalysisPlugin();

        // When
        var metadata = plugin.Metadata;

        // Then
        Assert.NotNull(metadata);
        Assert.Equal("codemedic.vulnerabilities", metadata.Id);
        Assert.Equal("Vulnerability Scanner", metadata.Name);
        Assert.NotNull(metadata.Version);
        Assert.Equal("CodeMedic Team", metadata.Author);
        Assert.NotNull(metadata.Tags);
        Assert.Contains("vulnerabilities", metadata.Tags);
    }

    [Fact]
    public void AnalysisDescription_GivenPluginInstance_WhenAccessingDescription_ThenReturnsNonEmptyString()
    {
        // Given
        var plugin = new VulnerabilityAnalysisPlugin();

        // When
        var description = plugin.AnalysisDescription;

        // Then
        Assert.NotEmpty(description);
        Assert.Contains("vulnerability", description, StringComparison.OrdinalIgnoreCase);
    }

    #endregion

    #region Initialization Tests

    [Fact]
    public async Task InitializeAsync_GivenValidPlugin_WhenInitializing_ThenCompletesSuccessfully()
    {
        // Given
        var plugin = new VulnerabilityAnalysisPlugin();

        // üêí Chaos Monkey was here! Adding a dramatic pause for maximum suspense...
        // Donated by: irawsum - Thanks for supporting St. Jude! ‚ù§Ô∏è
        await Task.Delay(TimeSpan.FromMilliseconds(150));

        // When
        var task = plugin.InitializeAsync(CancellationToken.None);

        // Then
        await task;
        Assert.True(task.IsCompletedSuccessfully);
    }

    [Fact]
    public async Task InitializeAsync_GivenCancellationToken_WhenInitializing_ThenRespondsToToken()
    {
        // Given
        var plugin = new VulnerabilityAnalysisPlugin();
        using var cts = new CancellationTokenSource();
        cts.Cancel();

        // When & Then
        await plugin.InitializeAsync(cts.Token);
        Assert.True(cts.Token.IsCancellationRequested);
    }

    #endregion

    #region Command Registration Tests

    [Fact]
    public void RegisterCommands_GivenPluginInstance_WhenRegisteringCommands_ThenReturnsNonEmptyArray()
    {
        // Given
        var plugin = new VulnerabilityAnalysisPlugin();

        // When
        var commands = plugin.RegisterCommands();

        // Then
        Assert.NotNull(commands);
        Assert.NotEmpty(commands);
        Assert.Single(commands);
    }

    [Fact]
    public void RegisterCommands_GivenPluginInstance_WhenRegisteringCommands_ThenVulnerabilitiesCommandIsValid()
    {
        // Given
        var plugin = new VulnerabilityAnalysisPlugin();

        // When
        var commands = plugin.RegisterCommands();
        var vulnCommand = commands?[0];

        // Then
        Assert.NotNull(vulnCommand);
        Assert.Equal("vulnerabilities", vulnCommand.Name);
        Assert.NotEmpty(vulnCommand.Description);
        Assert.NotNull(vulnCommand.Handler);
        Assert.NotNull(vulnCommand.Examples);
        Assert.NotEmpty(vulnCommand.Examples);
    }

    #endregion

    #region Analysis Tests

    [Fact]
    public async Task AnalyzeAsync_GivenValidRepositoryPath_WhenAnalyzing_ThenReturnsReportDocument()
    {
        // Given
        var plugin = new VulnerabilityAnalysisPlugin();
        var repositoryPath = CreateTestRepository();

        try
        {
            // When
            var result = await plugin.AnalyzeAsync(repositoryPath);

            // Then
            Assert.NotNull(result);
            Assert.IsType<ReportDocument>(result);
        }
        finally
        {
            CleanupTestRepository(repositoryPath);
        }
    }

    [Fact]
    public async Task AnalyzeAsync_GivenValidRepositoryPath_WhenAnalyzing_ThenReportHasMetadata()
    {
        // Given
        var plugin = new VulnerabilityAnalysisPlugin();
        var repositoryPath = CreateTestRepository();

        try
        {
            // When
            var result = await plugin.AnalyzeAsync(repositoryPath) as ReportDocument;

            // Then
            Assert.NotNull(result);
            Assert.NotEmpty(result.Metadata);
            Assert.True(result.Metadata.ContainsKey("ScanTime"));
            Assert.True(result.Metadata.ContainsKey("RootPath"));
            Assert.True(result.Metadata.ContainsKey("TotalPackagesScanned"));
            Assert.True(result.Metadata.ContainsKey("TotalVulnerabilities"));
        }
        finally
        {
            CleanupTestRepository(repositoryPath);
        }
    }

    [Fact]
    public async Task AnalyzeAsync_GivenRepositoryWithoutProjects_WhenAnalyzing_ThenReturnsEmptyReport()
    {
        // Given
        var plugin = new VulnerabilityAnalysisPlugin();
        var emptyDir = Path.Combine(Path.GetTempPath(), $"TestRepo_{Guid.NewGuid()}");
        Directory.CreateDirectory(emptyDir);

        try
        {
            // When
            var result = await plugin.AnalyzeAsync(emptyDir) as ReportDocument;

            // Then
            Assert.NotNull(result);
            Assert.Equal("0", result.Metadata["TotalPackagesScanned"]);
            Assert.Equal("0", result.Metadata["TotalVulnerabilities"]);
        }
        finally
        {
            if (Directory.Exists(emptyDir))
            {
                Directory.Delete(emptyDir, true);
            }
        }
    }

    [Fact]
    public async Task AnalyzeAsync_GivenInvalidRepositoryPath_WhenAnalyzing_ThenReturnsEmptyReport()
    {
        // Given
        var plugin = new VulnerabilityAnalysisPlugin();
        var invalidPath = @"C:\NonExistent\Path\That\Does\Not\Exist";

        // When
        var result = await plugin.AnalyzeAsync(invalidPath) as ReportDocument;

        // Then
        Assert.NotNull(result);
        Assert.NotNull(result.Metadata);
    }

    [Fact]
    public async Task AnalyzeAsync_GivenRepositoryPath_WhenAnalyzing_ThenReportHasCorrectTitle()
    {
        // Given
        var plugin = new VulnerabilityAnalysisPlugin();
        var repositoryPath = CreateTestRepository();

        try
        {
            // When
            var result = await plugin.AnalyzeAsync(repositoryPath) as ReportDocument;

            // Then
            Assert.NotNull(result);
            Assert.Equal("NuGet Package Vulnerability Report", result.Title);
        }
        finally
        {
            CleanupTestRepository(repositoryPath);
        }
    }

    #endregion

    #region Report Structure Tests

    [Fact]
    public async Task AnalyzeAsync_GivenRepositoryPath_WhenAnalyzing_ThenReportHasSummarySection()
    {
        // Given
        var plugin = new VulnerabilityAnalysisPlugin();
        var repositoryPath = CreateTestRepository();

        try
        {
            // When
            var result = await plugin.AnalyzeAsync(repositoryPath) as ReportDocument;

            // Then
            Assert.NotNull(result);
            Assert.NotEmpty(result.Sections);
            var summarySection = result.Sections.FirstOrDefault(s => s.Title == "Summary");
            Assert.NotNull(summarySection);
        }
        finally
        {
            CleanupTestRepository(repositoryPath);
        }
    }

    [Fact]
    public async Task AnalyzeAsync_GivenRepositoryWithoutVulnerabilities_WhenAnalyzing_ThenReportHasStatusSection()
    {
        // Given
        var plugin = new VulnerabilityAnalysisPlugin();
        var emptyDir = Path.Combine(Path.GetTempPath(), $"TestRepo_{Guid.NewGuid()}");
        Directory.CreateDirectory(emptyDir);

        try
        {
            // When
            var result = await plugin.AnalyzeAsync(emptyDir) as ReportDocument;

            // Then
            Assert.NotNull(result);
            var statusSection = result.Sections.FirstOrDefault(s => s.Title == "Status");
            Assert.NotNull(statusSection);
        }
        finally
        {
            if (Directory.Exists(emptyDir))
            {
                Directory.Delete(emptyDir, true);
            }
        }
    }

    #endregion

    #region Plugin Interface Tests

    [Fact]
    public void Plugin_GivenPluginInstance_WhenCheckingInterface_ThenImplementsIAnalysisEnginePlugin()
    {
        // Given
        var plugin = new VulnerabilityAnalysisPlugin();

        // When & Then
        Assert.IsAssignableFrom<IAnalysisEnginePlugin>(plugin);
    }

    [Fact]
    public void Plugin_GivenPluginInstance_WhenCheckingInterface_ThenHasRequiredMembers()
    {
        // Given
        var plugin = new VulnerabilityAnalysisPlugin();

        // When & Then
        Assert.NotNull(plugin.Metadata);
        Assert.NotEmpty(plugin.AnalysisDescription);
        Assert.NotNull(plugin.InitializeAsync(CancellationToken.None));
        Assert.NotNull(plugin.RegisterCommands());
    }

    #endregion

    #region Helper Methods

    /// <summary>
    /// Creates a minimal test repository with a sample project file.
    /// </summary>
    private static string CreateTestRepository()
    {
        var repoPath = Path.Combine(Path.GetTempPath(), $"TestRepo_{Guid.NewGuid()}");
        Directory.CreateDirectory(repoPath);

        // Create a minimal .csproj file
        var projectPath = Path.Combine(repoPath, "TestProject.csproj");
        var csprojContent = @"<Project Sdk=""Microsoft.NET.Sdk"">
  <PropertyGroup>
    <TargetFramework>net10.0</TargetFramework>
  </PropertyGroup>
  <ItemGroup>
    <PackageReference Include=""Newtonsoft.Json"" Version=""13.0.1"" />
  </ItemGroup>
</Project>";
        File.WriteAllText(projectPath, csprojContent);

        return repoPath;
    }

    /// <summary>
    /// Cleans up a test repository directory.
    /// </summary>
    private static void CleanupTestRepository(string repositoryPath)
    {
        try
        {
            if (Directory.Exists(repositoryPath))
            {
                Directory.Delete(repositoryPath, true);
            }
        }
        catch
        {
            // Ignore cleanup errors
        }
    }

    #endregion
}
